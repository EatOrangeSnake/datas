<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
    <title>Orange Team's Research on Computer Data Types - Natural Number Type</title>
    <style>
        body {
            margin: 0px;
            background-color: lightgoldenrodyellow;
            font-size: 2.5em;
            font-weight: bolder;
            user-select: none;
        }
        p {
            text-indent: 2em;
        }
        var {
            background-color: #00000080;
            border-radius: 0.25em;
        }
    </style>
</head>
<body>
    <h1>Orange Team's Research on Computer Data Types - Natural Number Type</h1>
    <h2>What is the main content of this article?</h2>
    <p>
        This article mainly introduces the Orange Team's research on computer data types - natural number type.
        In mathematics, natural numbers are a concept that most primary school students can understand.
        To understand this article, it is best to know this concept; if you don't, you can go and learn about it.
        The main content of this article is to implement natural number types on computers.
    </p>
    <h2>Why is it important to implement natural number types on computers?</h2>
    <p>
        Natural numbers are as important in mathematics as they are in computer implementation.
        There are many applications of natural numbers in mathematics, which are the first mathematical concepts humans initially encounter.
        Natural numbers in mathematics can describe quantities, counts, and other discrete and non-negative data.
        Therefore, it is necessary to implement natural number types on computers so that computers can better process and store natural number data.
    </p>
    <h2>Computer's basic unsigned integer types can also express discrete, non-negative data, why do we still need natural number types?</h2>
    <p>
        This is because the basic unsigned integer types of computers (such as
        <var>unsigned int</var>, <var>unsigned long</var>, <var>unsigned short</var>
        ) can also express discrete, non-negative data,
        but the basic integer types of computers cannot fully express the concept of natural numbers.
        Because the range of natural number types is infinite, while the integer types of computers can only represent a limited range.
        For example, the <var>unsigned int</var> type can only represent integers between <var>0</var> and <var>4294967295</var>,
        which limits the computer's ability to process natural numbers.
        Therefore, natural number types need to be implemented on computers to better process and store natural number data.
    </p>
    <h2>How to implement natural number types?</h2>
    <div>
        <h3>1. How to achieve the infinite nature of natural numbers? Can it really achieve infinite nature?</h3>
        <p>
            In fact, it is not possible to achieve infinite natural numbers on computers.
            The computer's memory can store data of limited size, which is obviously not possible,
            but we can try to extend the range of natural numbers as much as possible.
            For example, we can make the structure of natural number types into pointers,
            pointers pointing to memory blocks, and the memory blocks storing natural numbers.
            If we set the range of memory blocks to the total number of bytes in memory, we can maximize the range of natural numbers.
            This range reaches the limit of the computer, so it cannot truly achieve infinite natural numbers,
            but it can reach the maximum range that the computer can express, which can be approximated as infinite.
        </p>
        <h3>2. What does the value of the memory block storing natural numbers mean?</h3>
        <p>
            We can take the <var>unsigned long</var> type as an example.
            The range that <var>unsigned long</var> can express is <var>0</var> to <var>4294967295</var>,
            because it has 4 bytes, and each byte has 8 bits (256 values),
            so the number of values that <var>unsigned long</var> can express is <var>256<sup>4</sup></var>.
            The same applies to the memory block of natural numbers,
            we can make the length of the memory block <var>m</var> bytes,
            so its size is <var>256<sup>m</sup></var>, the range is <var>0</var> to <var>256<sup>m</sup> - 1</var>.
        </p>
        <h3>3. But it is not so easy to make the range of the memory block reach the total number of bytes in memory, what problems will this bring?</h3>
        <p>
            The memory allocator will never allocate the entire memory, so it will not really reach the total number of bytes in memory.
            In addition, the size of the memory block allocated by the memory allocator will also be affected by many factors,
            such as the memory management strategy of the operating system, the use of virtual memory, the running time of the program, etc.
            Therefore, even if we can set the range of the memory block to the total number of bytes in memory,
            we cannot guarantee that the size of the memory block allocated by the computer's memory allocator is what we want.
            Therefore, even if we achieve the infinite nature of natural numbers,
            we cannot guarantee that the size of the memory block allocated by the computer's memory allocator is what we want.
        </p>
        <h3>4. How to solve this problem?</h3>
        <p>
            The solution to this problem is simple, we can make the size of the memory block allocated by the memory allocator as small as possible.
            If the value of this memory block exceeds the range that this memory block can represent and causes a carry,
            we can reallocate the memory block, allocate a larger memory block, until the value no longer exceeds the range.
        </p>
        <h3>5. What is a better method?</h3>
        <p>
            In fact, each memory block has an attribute, which is its own size, that is, the length.
            If we compare the value of a memory block with a length of <var>m</var> that is all <var>0</var>
            with the value of another memory block with a length of <var>n</var> that is all <var>0</var>,
            we will find that they are completely equal, which indicates that two different memory blocks can represent the same value.
            If we can make the values of two different memory blocks not the same, then the range of natural numbers will be extended.
        </p>
        <h3>6. Advanced concepts</h3>
        <p>
            According to the fifth point, we can extend the range of natural numbers.
            We can try to create a number axis, each point on the number axis is a natural number.
            <ul>
                <li>If the size of a natural number's memory block is 0 bytes, then the range is <var>0</var>;</li>
                <li>If the size of a natural number's memory block is 1 byte, then the range is <var>0</var> to <var>255</var>;</li>
                <li>If the size of a natural number's memory block is 2 bytes, then the range is <var>0</var> to <var>65535</var>;</li>
            </ul>
            And so on, until the size of a natural number's memory block is <var>m</var> bytes,
            we can find that the representation ranges of different memory blocks overlap,
            if two memory blocks of different sizes but the same value will cause overlap,
            if we regard these ranges as a set of sets, then after union operation, we will get the range of <var>0</var> to <var>256<sup>m</sup> - 1</var>.
            But if we follow the following steps:
            <ul>
                <li>If the size of a natural number's memory block is 0 bytes, then the range is <var>0</var>;</li>
                <li>If the size of a natural number's memory block is 1 byte, then the range is <var>1</var> to <var>256</var>;</li>
                <li>If the size of a natural number's memory block is 2 bytes, then the range is <var>257</var> to <var>65792</var>;</li>
            </ul>
            And so on, until the size of a natural number's memory block is <var>m</var> bytes,
            then we get the range of <var>
                ∑<sub><var>k</var> = 0</sub><sup><var>m</var> - 1</sup>256<sup><var>k</var></sup>
                (when m is 0, it is 0)
            </var> to <var>
                ∑<sub><var>k</var> = 0</sub><sup><var>m</var></sup>256<sup><var>k</var></sup>
            </var>.
            If we regard these ranges as a set of sets, then after union operation, we will get the range of <var>0</var> to <var>
                ∑<sub><var>k</var> = 0</sub><sup><var>m</var></sup>256<sup><var>k</var></sup>
            </var>.
            We find that the result not only contains a coherent range of natural numbers but also corresponds one-to-one, which is more extensive than the previous expression range.
            In this way, we can represent infinite natural numbers.
        </p>
    </div>
    <h2>Examples</h2>
    <p>
        The following are some examples showing the contents of memory blocks corresponding to different natural numbers.
        <ul>
            <li>0:</li>
            <li>1:00</li>
            <li>2:01</li>
            <li>...</li>
            <li>256:ff</li>
            <li>257:00 00</li>
            <li>258:01 00</li>
            <li>...</li>
            <li>65792:ff ff</li>
            <li>65793:00 00 00</li>
            <li>65794:01 00 00</li>
            <li>...</li>
        </ul>
    </p>
</body>
</html>